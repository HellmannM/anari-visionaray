// Copyright 2021 The Khronos Group
// SPDX-License-Identifier: Apache-2.0

// This file was generated by generate_queries.py
// Don't make changes to this directly

#include <stdint.h>
#include <math.h>
#include <anari/anari.h>
namespace visionaray {
static int subtype_hash(const char *str) {
   static const uint32_t table[] = {0x7a6f0012u,0x6a65002bu,0x0u,0x0u,0x0u,0x0u,0x6e6d0041u,0x0u,0x0u,0x0u,0x62610048u,0x0u,0x7372004du,0x70650059u,0x76750072u,0x0u,0x75700076u,0x73720090u,0x6f6e001du,0x0u,0x0u,0x0u,0x0u,0x0u,0x73720020u,0x0u,0x0u,0x0u,0x6d6c0024u,0x6665001eu,0x100001fu,0x80000000u,0x77760021u,0x66650022u,0x1000023u,0x80000001u,0x6a690025u,0x6f6e0026u,0x65640027u,0x66650028u,0x73720029u,0x100002au,0x80000002u,0x67660030u,0x0u,0x0u,0x0u,0x73720036u,0x62610031u,0x76750032u,0x6d6c0033u,0x75740034u,0x1000035u,0x80000003u,0x66650037u,0x64630038u,0x75740039u,0x605f003au,0x6d6c003bu,0x6a69003cu,0x6867003du,0x6968003eu,0x7574003fu,0x1000040u,0x80000004u,0x62610042u,0x68670043u,0x66650044u,0x32310045u,0x45440046u,0x1000047u,0x80000005u,0x75740049u,0x7574004au,0x6665004bu,0x100004cu,0x80000006u,0x7574004eu,0x6968004fu,0x706f0050u,0x68670051u,0x73720052u,0x62610053u,0x71700054u,0x69680055u,0x6a690056u,0x64630057u,0x1000058u,0x80000007u,0x73720064u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6a69006eu,0x74730065u,0x71700066u,0x66650067u,0x64630068u,0x75740069u,0x6a69006au,0x7776006bu,0x6665006cu,0x100006du,0x80000008u,0x6f6e006fu,0x75740070u,0x1000071u,0x80000009u,0x62610073u,0x65640074u,0x1000075u,0x8000000au,0x6968007bu,0x0u,0x0u,0x0u,0x73720080u,0x6665007cu,0x7372007du,0x6665007eu,0x100007fu,0x8000000bu,0x76750081u,0x64630082u,0x75740083u,0x76750084u,0x73720085u,0x66650086u,0x65640087u,0x53520088u,0x66650089u,0x6867008au,0x7675008bu,0x6d6c008cu,0x6261008du,0x7372008eu,0x100008fu,0x8000000cu,0x6a690091u,0x62610092u,0x6f6e0093u,0x68670094u,0x6d6c0095u,0x66650096u,0x1000097u,0x8000000du};
   uint32_t cur = 0x75630000u;
   for(int i = 0;cur!=0;++i) {
      uint32_t idx = cur&0xFFFFu;
      uint32_t low = (cur>>16u)&0xFFu;
      uint32_t high = (cur>>24u)&0xFFu;
      uint32_t c = (uint32_t)str[i];
      if(c>=low && c<high) {
         cur = table[idx+c-low];
      } else {
         break;
      }
      if(cur&0x80000000u) {
         return cur&0xFFFFu;
      }
      if(str[i]==0) {
         break;
      }
   }
   return -1;
}
static int param_hash(const char *str) {
   static const uint32_t table[] = {0x746c0017u,0x6261003cu,0x7061004bu,0x6a61007au,0x0u,0x7061008eu,0x666500a7u,0x666500afu,0x6f6d00b5u,0x0u,0x0u,0x6a69016cu,0x62610171u,0x66610179u,0x76700184u,0x736f01abu,0x0u,0x66610202u,0x76690213u,0x0u,0x71700299u,0x7065029bu,0x736f0304u,0x7170001fu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x71700037u,0x69680020u,0x62610021u,0x4e430022u,0x7675002du,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f0033u,0x7574002eu,0x706f002fu,0x67660030u,0x67660031u,0x1000032u,0x80000000u,0x65640034u,0x66650035u,0x1000036u,0x80000001u,0x66650038u,0x64630039u,0x7574003au,0x100003bu,0x80000002u,0x6463003du,0x6c6b003eu,0x6867003fu,0x73720040u,0x706f0041u,0x76750042u,0x6f6e0043u,0x65640044u,0x44430045u,0x706f0046u,0x6d6c0047u,0x706f0048u,0x73720049u,0x100004au,0x80000003u,0x716d005au,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610064u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6d6c0076u,0x6665005eu,0x0u,0x0u,0x74730062u,0x7372005fu,0x62610060u,0x1000061u,0x80000004u,0x1000063u,0x80000005u,0x6f6e0065u,0x6f6e0066u,0x66650067u,0x6d6c0068u,0x2f2e0069u,0x6563006au,0x706f006cu,0x66650071u,0x6d6c006du,0x706f006eu,0x7372006fu,0x1000070u,0x80000006u,0x71700072u,0x75740073u,0x69680074u,0x1000075u,0x80000007u,0x706f0077u,0x73720078u,0x1000079u,0x80000008u,0x75740083u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x73720086u,0x62610084u,0x1000085u,0x80000009u,0x66650087u,0x64630088u,0x75740089u,0x6a69008au,0x706f008bu,0x6f6e008cu,0x100008du,0x8000000au,0x7372009du,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6d6c009fu,0x0u,0x0u,0x0u,0x0u,0x0u,0x777600a4u,0x100009eu,0x8000000bu,0x757400a0u,0x666500a1u,0x737200a2u,0x10000a3u,0x8000000cu,0x7a7900a5u,0x10000a6u,0x8000000du,0x706f00a8u,0x6e6d00a9u,0x666500aau,0x757400abu,0x737200acu,0x7a7900adu,0x10000aeu,0x8000000eu,0x6a6900b0u,0x686700b1u,0x696800b2u,0x757400b3u,0x10000b4u,0x8000000fu,0x626100b7u,0x75410113u,0x686700b8u,0x666500b9u,0x530000bau,0x80000010u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6665010du,0x6867010eu,0x6a69010fu,0x706f0110u,0x6f6e0111u,0x1000112u,0x80000011u,0x75740147u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x67660150u,0x0u,0x0u,0x0u,0x0u,0x73720156u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7574015fu,0x66650165u,0x75740148u,0x73720149u,0x6a69014au,0x6362014bu,0x7675014cu,0x7574014du,0x6665014eu,0x100014fu,0x80000012u,0x67660151u,0x74730152u,0x66650153u,0x75740154u,0x1000155u,0x80000013u,0x62610157u,0x6f6e0158u,0x74730159u,0x6766015au,0x706f015bu,0x7372015cu,0x6e6d015du,0x100015eu,0x80000014u,0x62610160u,0x6f6e0161u,0x64630162u,0x66650163u,0x1000164u,0x80000015u,0x6f6e0166u,0x74730167u,0x6a690168u,0x75740169u,0x7a79016au,0x100016bu,0x80000016u,0x6867016du,0x6968016eu,0x7574016fu,0x1000170u,0x80000017u,0x75740172u,0x66650173u,0x73720174u,0x6a690175u,0x62610176u,0x6d6c0177u,0x1000178u,0x80000018u,0x6e6d017eu,0x0u,0x0u,0x0u,0x62610181u,0x6665017fu,0x1000180u,0x80000019u,0x73720182u,0x1000183u,0x8000001au,0x6261018au,0x0u,0x6a690190u,0x0u,0x0u,0x75740195u,0x6463018bu,0x6a69018cu,0x7574018du,0x7a79018eu,0x100018fu,0x8000001bu,0x68670191u,0x6a690192u,0x6f6e0193u,0x1000194u,0x8000001cu,0x554f0196u,0x6766019cu,0x0u,0x0u,0x0u,0x0u,0x737201a2u,0x6766019du,0x7473019eu,0x6665019fu,0x757401a0u,0x10001a1u,0x8000001du,0x626101a3u,0x6f6e01a4u,0x747301a5u,0x676601a6u,0x706f01a7u,0x737201a8u,0x6e6d01a9u,0x10001aau,0x8000001eu,0x787301afu,0x0u,0x0u,0x6a6901bdu,0x6a6901b4u,0x0u,0x0u,0x0u,0x666501bau,0x757401b5u,0x6a6901b6u,0x706f01b7u,0x6f6e01b8u,0x10001b9u,0x8000001fu,0x737201bbu,0x10001bcu,0x80000020u,0x6e6d01beu,0x6a6901bfu,0x757401c0u,0x6a6901c1u,0x777601c2u,0x666501c3u,0x2f2e01c4u,0x736101c5u,0x757401d7u,0x0u,0x706f01e7u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6f6401ecu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x626101fcu,0x757401d8u,0x737201d9u,0x6a6901dau,0x636201dbu,0x767501dcu,0x757401ddu,0x666501deu,0x343001dfu,0x10001e3u,0x10001e4u,0x10001e5u,0x10001e6u,0x80000021u,0x80000022u,0x80000023u,0x80000024u,0x6d6c01e8u,0x706f01e9u,0x737201eau,0x10001ebu,0x80000025u,0x10001f7u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x656401f8u,0x80000026u,0x666501f9u,0x797801fau,0x10001fbu,0x80000027u,0x656401fdu,0x6a6901feu,0x767501ffu,0x74730200u,0x1000201u,0x80000028u,0x65640207u,0x0u,0x0u,0x0u,0x6f6e020cu,0x6a690208u,0x76750209u,0x7473020au,0x100020bu,0x80000029u,0x6564020du,0x6665020eu,0x7372020fu,0x66650210u,0x73720211u,0x1000212u,0x8000002au,0x7b7a0220u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610223u,0x0u,0x0u,0x0u,0x62610229u,0x73720293u,0x66650221u,0x1000222u,0x8000002bu,0x64630224u,0x6a690225u,0x6f6e0226u,0x68670227u,0x1000228u,0x8000002cu,0x7574022au,0x7675022bu,0x7473022cu,0x4443022du,0x6261022eu,0x6d6c022fu,0x6d6c0230u,0x63620231u,0x62610232u,0x64630233u,0x6c6b0234u,0x56000235u,0x8000002du,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7473028bu,0x6665028cu,0x7372028du,0x4544028eu,0x6261028fu,0x75740290u,0x62610291u,0x1000292u,0x8000002eu,0x67660294u,0x62610295u,0x64630296u,0x66650297u,0x1000298u,0x8000002fu,0x100029au,0x80000030u,0x737202a6u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6d6c02ffu,0x757402a7u,0x666502a8u,0x797802a9u,0x2f2e02aau,0x756102abu,0x757402bfu,0x0u,0x706102cfu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f02e4u,0x0u,0x706f02eau,0x0u,0x626102f2u,0x0u,0x626102f8u,0x757402c0u,0x737202c1u,0x6a6902c2u,0x636202c3u,0x767502c4u,0x757402c5u,0x666502c6u,0x343002c7u,0x10002cbu,0x10002ccu,0x10002cdu,0x10002ceu,0x80000031u,0x80000032u,0x80000033u,0x80000034u,0x717002deu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6d6c02e0u,0x10002dfu,0x80000035u,0x706f02e1u,0x737202e2u,0x10002e3u,0x80000036u,0x737202e5u,0x6e6d02e6u,0x626102e7u,0x6d6c02e8u,0x10002e9u,0x80000037u,0x747302ebu,0x6a6902ecu,0x757402edu,0x6a6902eeu,0x706f02efu,0x6f6e02f0u,0x10002f1u,0x80000038u,0x656402f3u,0x6a6902f4u,0x767502f5u,0x747302f6u,0x10002f7u,0x80000039u,0x6f6e02f9u,0x686702fau,0x666502fbu,0x6f6e02fcu,0x757402fdu,0x10002feu,0x8000003au,0x76750300u,0x6e6d0301u,0x66650302u,0x1000303u,0x8000003bu,0x73720308u,0x0u,0x0u,0x6261030cu,0x6d6c0309u,0x6564030au,0x100030bu,0x8000003cu,0x7170030du,0x4e4d030eu,0x706f030fu,0x65640310u,0x66650311u,0x32310312u,0x1000313u,0x8000003du};
   uint32_t cur = 0x78610000u;
   for(int i = 0;cur!=0;++i) {
      uint32_t idx = cur&0xFFFFu;
      uint32_t low = (cur>>16u)&0xFFu;
      uint32_t high = (cur>>24u)&0xFFu;
      uint32_t c = (uint32_t)str[i];
      if(c>=low && c<high) {
         cur = table[idx+c-low];
      } else {
         break;
      }
      if(cur&0x80000000u) {
         return cur&0xFFFFu;
      }
      if(str[i]==0) {
         break;
      }
   }
   return -1;
}
static int info_hash(const char *str) {
   static const uint32_t table[] = {0x69680014u,0x6665001bu,0x796c0038u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6a610057u,0x0u,0x0u,0x6261006cu,0x0u,0x66650075u,0x706f007du,0x0u,0x7473008cu,0x6261008fu,0x62610015u,0x6f6e0016u,0x6f6e0017u,0x66650018u,0x6d6c0019u,0x100001au,0x8000000au,0x7466001cu,0x6261002au,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6463002fu,0x7675002bu,0x6d6c002cu,0x7574002du,0x100002eu,0x80000001u,0x73720030u,0x6a690031u,0x71700032u,0x75740033u,0x6a690034u,0x706f0035u,0x6f6e0036u,0x1000037u,0x80000004u,0x66650045u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7574004fu,0x6e6d0046u,0x66650047u,0x6f6e0048u,0x75740049u,0x5554004au,0x7a79004bu,0x7170004cu,0x6665004du,0x100004eu,0x80000005u,0x66650050u,0x6f6e0051u,0x74730052u,0x6a690053u,0x706f0054u,0x6f6e0055u,0x1000056u,0x80000008u,0x79780060u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6f6e0066u,0x6a690061u,0x6e6d0062u,0x76750063u,0x6e6d0064u,0x1000065u,0x80000003u,0x6a690067u,0x6e6d0068u,0x76750069u,0x6e6d006au,0x100006bu,0x80000002u,0x7372006du,0x6261006eu,0x6e6d006fu,0x66650070u,0x75740071u,0x66650072u,0x73720073u,0x1000074u,0x80000009u,0x72710076u,0x76750077u,0x6a690078u,0x73720079u,0x6665007au,0x6564007bu,0x100007cu,0x80000000u,0x7675007eu,0x7372007fu,0x64630080u,0x66650081u,0x46450082u,0x79780083u,0x75740084u,0x66650085u,0x6f6e0086u,0x74730087u,0x6a690088u,0x706f0089u,0x6f6e008au,0x100008bu,0x80000007u,0x6665008du,0x100008eu,0x8000000bu,0x6d6c0090u,0x76750091u,0x66650092u,0x1000093u,0x80000006u};
   uint32_t cur = 0x77630000u;
   for(int i = 0;cur!=0;++i) {
      uint32_t idx = cur&0xFFFFu;
      uint32_t low = (cur>>16u)&0xFFu;
      uint32_t high = (cur>>24u)&0xFFu;
      uint32_t c = (uint32_t)str[i];
      if(c>=low && c<high) {
         cur = table[idx+c-low];
      } else {
         break;
      }
      if(cur&0x80000000u) {
         return cur&0xFFFFu;
      }
      if(str[i]==0) {
         break;
      }
   }
   return -1;
}
static const int32_t anari_true = 1;
static const int32_t anari_false = 0;
const char ** query_extensions() {
   static const char *extensions[] = {
      "ANARI_KHR_CAMERA_ORTHOGRAPHIC",
      "ANARI_KHR_CAMERA_PERSPECTIVE",
      "ANARI_KHR_GEOMETRY_CONE",
      "ANARI_KHR_GEOMETRY_CURVE",
      "ANARI_KHR_GEOMETRY_CYLINDER",
      "ANARI_KHR_GEOMETRY_QUAD",
      "ANARI_KHR_GEOMETRY_SPHERE",
      "ANARI_KHR_GEOMETRY_TRIANGLE",
      "ANARI_KHR_MATERIAL_MATTE",
      "ANARI_KHR_LIGHT_POINT",
      "ANARI_KHR_SAMPLER_IMAGE1D",
      "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
      0
   };
   return extensions;
}
const char ** query_object_types(ANARIDataType type) {
   switch(type) {
      case ANARI_RENDERER:
      {
         static const char *ANARI_RENDERER_subtypes[] = {"default", "direct_light", 0};
         return ANARI_RENDERER_subtypes;
      }
      case ANARI_CAMERA:
      {
         static const char *ANARI_CAMERA_subtypes[] = {"orthographic", "perspective", 0};
         return ANARI_CAMERA_subtypes;
      }
      case ANARI_GEOMETRY:
      {
         static const char *ANARI_GEOMETRY_subtypes[] = {"cone", "curve", "cylinder", "quad", "sphere", "triangle", 0};
         return ANARI_GEOMETRY_subtypes;
      }
      case ANARI_MATERIAL:
      {
         static const char *ANARI_MATERIAL_subtypes[] = {"matte", 0};
         return ANARI_MATERIAL_subtypes;
      }
      case ANARI_LIGHT:
      {
         static const char *ANARI_LIGHT_subtypes[] = {"point", 0};
         return ANARI_LIGHT_subtypes;
      }
      case ANARI_SAMPLER:
      {
         static const char *ANARI_SAMPLER_subtypes[] = {"image1D", 0};
         return ANARI_SAMPLER_subtypes;
      }
      case ANARI_SPATIAL_FIELD:
      {
         static const char *ANARI_SPATIAL_FIELD_subtypes[] = {"structuredRegular", 0};
         return ANARI_SPATIAL_FIELD_subtypes;
      }
      default:
      {
         static const char *none_subtypes[] = {0};
         return none_subtypes;
      }
   }
}
static const void * ANARI_RENDERER_default_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_default_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 25:
         return ANARI_RENDERER_default_name_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_RENDERER_direct_light_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_direct_light_backgroundColor_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
            static const float default_value[4] = {1.000000f, 1.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "background color and alpha (RGBA)";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_direct_light_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 25:
         return ANARI_RENDERER_direct_light_name_info(paramType, infoName, infoType);
      case 3:
         return ANARI_RENDERER_direct_light_backgroundColor_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_DEVICE_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_DEVICE_statusCallback_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "callback used to report information to the application";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_DEVICE_statusCallbackUserData_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional pointer passed as the first argument of the status callback";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_DEVICE_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 25:
         return ANARI_DEVICE_name_info(paramType, infoName, infoType);
      case 45:
         return ANARI_DEVICE_statusCallback_info(paramType, infoName, infoType);
      case 46:
         return ANARI_DEVICE_statusCallbackUserData_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_ARRAY1D_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_ARRAY1D_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 25:
         return ANARI_ARRAY1D_name_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_ARRAY2D_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_ARRAY2D_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 25:
         return ANARI_ARRAY2D_name_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_ARRAY3D_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_ARRAY3D_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 25:
         return ANARI_ARRAY3D_name_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_FRAME_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_world_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "world to be rendererd";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_renderer_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "renderer which renders the frame";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_camera_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "camera used to render the world";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_size_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "size of the frame in pixels (width, height)";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_channel_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "enables mapping the color channel as the type specified";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_DATA_TYPE && infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8_VEC4, ANARI_UFIXED8_RGBA_SRGB, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_channel_depth_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "enables mapping the color channel as the type specified";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_DATA_TYPE && infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 25:
         return ANARI_FRAME_name_info(paramType, infoName, infoType);
      case 60:
         return ANARI_FRAME_world_info(paramType, infoName, infoType);
      case 42:
         return ANARI_FRAME_renderer_info(paramType, infoName, infoType);
      case 4:
         return ANARI_FRAME_camera_info(paramType, infoName, infoType);
      case 43:
         return ANARI_FRAME_size_info(paramType, infoName, infoType);
      case 6:
         return ANARI_FRAME_channel_color_info(paramType, infoName, infoType);
      case 7:
         return ANARI_FRAME_channel_depth_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GROUP_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GROUP_surface_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array of surface objects";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_SURFACE, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GROUP_volume_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array of volume objects";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_VOLUME, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GROUP_light_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array of light objects";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_LIGHT, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GROUP_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 25:
         return ANARI_GROUP_name_info(paramType, infoName, infoType);
      case 47:
         return ANARI_GROUP_surface_info(paramType, infoName, infoType);
      case 59:
         return ANARI_GROUP_volume_info(paramType, infoName, infoType);
      case 23:
         return ANARI_GROUP_light_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_WORLD_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_WORLD_instance_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array of instance objects in the world";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_INSTANCE, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_WORLD_surface_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array of non-instanced surface objects in the world";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_SURFACE, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_WORLD_volume_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array of non-instanced volume objects in the world";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_LIGHT, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_WORLD_light_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array of non-instanced light objects in the world";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_LIGHT, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_WORLD_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 25:
         return ANARI_WORLD_name_info(paramType, infoName, infoType);
      case 21:
         return ANARI_WORLD_instance_info(paramType, infoName, infoType);
      case 47:
         return ANARI_WORLD_surface_info(paramType, infoName, infoType);
      case 59:
         return ANARI_WORLD_volume_info(paramType, infoName, infoType);
      case 23:
         return ANARI_WORLD_light_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SURFACE_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SURFACE_geometry_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "geometry object defining the surface geometry";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SURFACE_material_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "material object defining the surface appearance";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SURFACE_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 25:
         return ANARI_SURFACE_name_info(paramType, infoName, infoType);
      case 14:
         return ANARI_SURFACE_geometry_info(paramType, infoName, infoType);
      case 24:
         return ANARI_SURFACE_material_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "point";
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "camera position";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_direction_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, -1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "direction";
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "main viewing direction";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_up_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 1.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "direction";
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "camera up direction";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_imageRegion_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_BOX2 && infoType == ANARI_FLOAT32_BOX2) {
            static const float default_value[4] = {0.000000f, 0.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "region mapped to the frame";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_aspect_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "aspect ratio";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_height_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "height of image plane";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_near_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "near plane clip distance";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_far_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "far plane clip distance";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 25:
         return ANARI_CAMERA_orthographic_name_info(paramType, infoName, infoType);
      case 31:
         return ANARI_CAMERA_orthographic_position_info(paramType, infoName, infoType);
      case 10:
         return ANARI_CAMERA_orthographic_direction_info(paramType, infoName, infoType);
      case 48:
         return ANARI_CAMERA_orthographic_up_info(paramType, infoName, infoType);
      case 17:
         return ANARI_CAMERA_orthographic_imageRegion_info(paramType, infoName, infoType);
      case 2:
         return ANARI_CAMERA_orthographic_aspect_info(paramType, infoName, infoType);
      case 15:
         return ANARI_CAMERA_orthographic_height_info(paramType, infoName, infoType);
      case 26:
         return ANARI_CAMERA_orthographic_near_info(paramType, infoName, infoType);
      case 11:
         return ANARI_CAMERA_orthographic_far_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_PERSPECTIVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "point";
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "camera position";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_PERSPECTIVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_direction_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, -1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "direction";
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "main viewing direction";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_PERSPECTIVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_up_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 1.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "direction";
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "camera up direction";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_PERSPECTIVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_imageRegion_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_BOX2 && infoType == ANARI_FLOAT32_BOX2) {
            static const float default_value[4] = {0.000000f, 0.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "region mapped to the frame";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_PERSPECTIVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_fovy_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.047198f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertical field of view in radians";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_PERSPECTIVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_aspect_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "aspect ratio";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_PERSPECTIVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_near_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "near plane clip distance";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_PERSPECTIVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_far_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "far plane clip distance";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_PERSPECTIVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 25:
         return ANARI_CAMERA_perspective_name_info(paramType, infoName, infoType);
      case 31:
         return ANARI_CAMERA_perspective_position_info(paramType, infoName, infoType);
      case 10:
         return ANARI_CAMERA_perspective_direction_info(paramType, infoName, infoType);
      case 48:
         return ANARI_CAMERA_perspective_up_info(paramType, infoName, infoType);
      case 17:
         return ANARI_CAMERA_perspective_imageRegion_info(paramType, infoName, infoType);
      case 13:
         return ANARI_CAMERA_perspective_fovy_info(paramType, infoName, infoType);
      case 2:
         return ANARI_CAMERA_perspective_aspect_info(paramType, infoName, infoType);
      case 26:
         return ANARI_CAMERA_perspective_near_info(paramType, infoName, infoType);
      case 11:
         return ANARI_CAMERA_perspective_far_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_primitive_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_primitive_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_primitive_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_primitive_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_primitive_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_primitive_id_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "primitive id";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_vertex_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex position";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_vertex_radius_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex radius";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_vertex_cap_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex cap type";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT8, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_vertex_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_vertex_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_vertex_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_vertex_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_vertex_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_primitive_index_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "index array";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32_VEC2, ANARI_UINT64_VEC2, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_caps_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "none";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "global cap type";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"none", "first", "second", "both", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 25:
         return ANARI_GEOMETRY_cone_name_info(paramType, infoName, infoType);
      case 37:
         return ANARI_GEOMETRY_cone_primitive_color_info(paramType, infoName, infoType);
      case 33:
         return ANARI_GEOMETRY_cone_primitive_attribute0_info(paramType, infoName, infoType);
      case 34:
         return ANARI_GEOMETRY_cone_primitive_attribute1_info(paramType, infoName, infoType);
      case 35:
         return ANARI_GEOMETRY_cone_primitive_attribute2_info(paramType, infoName, infoType);
      case 36:
         return ANARI_GEOMETRY_cone_primitive_attribute3_info(paramType, infoName, infoType);
      case 38:
         return ANARI_GEOMETRY_cone_primitive_id_info(paramType, infoName, infoType);
      case 56:
         return ANARI_GEOMETRY_cone_vertex_position_info(paramType, infoName, infoType);
      case 57:
         return ANARI_GEOMETRY_cone_vertex_radius_info(paramType, infoName, infoType);
      case 53:
         return ANARI_GEOMETRY_cone_vertex_cap_info(paramType, infoName, infoType);
      case 54:
         return ANARI_GEOMETRY_cone_vertex_color_info(paramType, infoName, infoType);
      case 49:
         return ANARI_GEOMETRY_cone_vertex_attribute0_info(paramType, infoName, infoType);
      case 50:
         return ANARI_GEOMETRY_cone_vertex_attribute1_info(paramType, infoName, infoType);
      case 51:
         return ANARI_GEOMETRY_cone_vertex_attribute2_info(paramType, infoName, infoType);
      case 52:
         return ANARI_GEOMETRY_cone_vertex_attribute3_info(paramType, infoName, infoType);
      case 39:
         return ANARI_GEOMETRY_cone_primitive_index_info(paramType, infoName, infoType);
      case 5:
         return ANARI_GEOMETRY_cone_caps_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_primitive_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_primitive_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_primitive_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_primitive_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_primitive_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_primitive_id_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "primitive id";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_vertex_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex position";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_vertex_radius_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex radius";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_vertex_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_vertex_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_vertex_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_vertex_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_vertex_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_primitive_index_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "index array";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_radius_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "global radius";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 25:
         return ANARI_GEOMETRY_curve_name_info(paramType, infoName, infoType);
      case 37:
         return ANARI_GEOMETRY_curve_primitive_color_info(paramType, infoName, infoType);
      case 33:
         return ANARI_GEOMETRY_curve_primitive_attribute0_info(paramType, infoName, infoType);
      case 34:
         return ANARI_GEOMETRY_curve_primitive_attribute1_info(paramType, infoName, infoType);
      case 35:
         return ANARI_GEOMETRY_curve_primitive_attribute2_info(paramType, infoName, infoType);
      case 36:
         return ANARI_GEOMETRY_curve_primitive_attribute3_info(paramType, infoName, infoType);
      case 38:
         return ANARI_GEOMETRY_curve_primitive_id_info(paramType, infoName, infoType);
      case 56:
         return ANARI_GEOMETRY_curve_vertex_position_info(paramType, infoName, infoType);
      case 57:
         return ANARI_GEOMETRY_curve_vertex_radius_info(paramType, infoName, infoType);
      case 54:
         return ANARI_GEOMETRY_curve_vertex_color_info(paramType, infoName, infoType);
      case 49:
         return ANARI_GEOMETRY_curve_vertex_attribute0_info(paramType, infoName, infoType);
      case 50:
         return ANARI_GEOMETRY_curve_vertex_attribute1_info(paramType, infoName, infoType);
      case 51:
         return ANARI_GEOMETRY_curve_vertex_attribute2_info(paramType, infoName, infoType);
      case 52:
         return ANARI_GEOMETRY_curve_vertex_attribute3_info(paramType, infoName, infoType);
      case 39:
         return ANARI_GEOMETRY_curve_primitive_index_info(paramType, infoName, infoType);
      case 41:
         return ANARI_GEOMETRY_curve_radius_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_primitive_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_primitive_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_primitive_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_primitive_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_primitive_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_primitive_id_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "primitive id";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_vertex_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex position";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_vertex_cap_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "cylinder cap type";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT8, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_vertex_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_vertex_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_vertex_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_vertex_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_vertex_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_primitive_index_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "index array";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32_VEC2, ANARI_UINT64_VEC2, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_primitive_radius_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "cylinder radius";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_radius_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "global cylinder radius";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_caps_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "none";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "global cylinder cap type";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"none", "first", "second", "both", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 25:
         return ANARI_GEOMETRY_cylinder_name_info(paramType, infoName, infoType);
      case 37:
         return ANARI_GEOMETRY_cylinder_primitive_color_info(paramType, infoName, infoType);
      case 33:
         return ANARI_GEOMETRY_cylinder_primitive_attribute0_info(paramType, infoName, infoType);
      case 34:
         return ANARI_GEOMETRY_cylinder_primitive_attribute1_info(paramType, infoName, infoType);
      case 35:
         return ANARI_GEOMETRY_cylinder_primitive_attribute2_info(paramType, infoName, infoType);
      case 36:
         return ANARI_GEOMETRY_cylinder_primitive_attribute3_info(paramType, infoName, infoType);
      case 38:
         return ANARI_GEOMETRY_cylinder_primitive_id_info(paramType, infoName, infoType);
      case 56:
         return ANARI_GEOMETRY_cylinder_vertex_position_info(paramType, infoName, infoType);
      case 53:
         return ANARI_GEOMETRY_cylinder_vertex_cap_info(paramType, infoName, infoType);
      case 54:
         return ANARI_GEOMETRY_cylinder_vertex_color_info(paramType, infoName, infoType);
      case 49:
         return ANARI_GEOMETRY_cylinder_vertex_attribute0_info(paramType, infoName, infoType);
      case 50:
         return ANARI_GEOMETRY_cylinder_vertex_attribute1_info(paramType, infoName, infoType);
      case 51:
         return ANARI_GEOMETRY_cylinder_vertex_attribute2_info(paramType, infoName, infoType);
      case 52:
         return ANARI_GEOMETRY_cylinder_vertex_attribute3_info(paramType, infoName, infoType);
      case 39:
         return ANARI_GEOMETRY_cylinder_primitive_index_info(paramType, infoName, infoType);
      case 40:
         return ANARI_GEOMETRY_cylinder_primitive_radius_info(paramType, infoName, infoType);
      case 41:
         return ANARI_GEOMETRY_cylinder_radius_info(paramType, infoName, infoType);
      case 5:
         return ANARI_GEOMETRY_cylinder_caps_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 5;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_primitive_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 5;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_primitive_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 5;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_primitive_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 5;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_primitive_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 5;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_primitive_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 5;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_primitive_id_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "primitive id";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 5;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_vertex_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex position";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 5;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_vertex_normal_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex normal";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_FIXED16_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 5;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_vertex_tangent_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex normal";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_FIXED16_VEC3, ANARI_FLOAT32_VEC4, ANARI_FIXED16_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 5;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_vertex_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 5;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_vertex_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 5;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_vertex_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 5;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_vertex_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 5;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_vertex_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 5;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_primitive_index_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "index array";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32_VEC4, ANARI_UINT64_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 5;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 25:
         return ANARI_GEOMETRY_quad_name_info(paramType, infoName, infoType);
      case 37:
         return ANARI_GEOMETRY_quad_primitive_color_info(paramType, infoName, infoType);
      case 33:
         return ANARI_GEOMETRY_quad_primitive_attribute0_info(paramType, infoName, infoType);
      case 34:
         return ANARI_GEOMETRY_quad_primitive_attribute1_info(paramType, infoName, infoType);
      case 35:
         return ANARI_GEOMETRY_quad_primitive_attribute2_info(paramType, infoName, infoType);
      case 36:
         return ANARI_GEOMETRY_quad_primitive_attribute3_info(paramType, infoName, infoType);
      case 38:
         return ANARI_GEOMETRY_quad_primitive_id_info(paramType, infoName, infoType);
      case 56:
         return ANARI_GEOMETRY_quad_vertex_position_info(paramType, infoName, infoType);
      case 55:
         return ANARI_GEOMETRY_quad_vertex_normal_info(paramType, infoName, infoType);
      case 58:
         return ANARI_GEOMETRY_quad_vertex_tangent_info(paramType, infoName, infoType);
      case 54:
         return ANARI_GEOMETRY_quad_vertex_color_info(paramType, infoName, infoType);
      case 49:
         return ANARI_GEOMETRY_quad_vertex_attribute0_info(paramType, infoName, infoType);
      case 50:
         return ANARI_GEOMETRY_quad_vertex_attribute1_info(paramType, infoName, infoType);
      case 51:
         return ANARI_GEOMETRY_quad_vertex_attribute2_info(paramType, infoName, infoType);
      case 52:
         return ANARI_GEOMETRY_quad_vertex_attribute3_info(paramType, infoName, infoType);
      case 39:
         return ANARI_GEOMETRY_quad_primitive_index_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_primitive_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_primitive_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_primitive_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_primitive_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_primitive_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_primitive_id_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "primitive id";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_vertex_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "sphere position";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_vertex_radius_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "sphere radius";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_vertex_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_vertex_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_vertex_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_vertex_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_vertex_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_primitive_index_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "index array";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_radius_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "global sphere radius";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 25:
         return ANARI_GEOMETRY_sphere_name_info(paramType, infoName, infoType);
      case 37:
         return ANARI_GEOMETRY_sphere_primitive_color_info(paramType, infoName, infoType);
      case 33:
         return ANARI_GEOMETRY_sphere_primitive_attribute0_info(paramType, infoName, infoType);
      case 34:
         return ANARI_GEOMETRY_sphere_primitive_attribute1_info(paramType, infoName, infoType);
      case 35:
         return ANARI_GEOMETRY_sphere_primitive_attribute2_info(paramType, infoName, infoType);
      case 36:
         return ANARI_GEOMETRY_sphere_primitive_attribute3_info(paramType, infoName, infoType);
      case 38:
         return ANARI_GEOMETRY_sphere_primitive_id_info(paramType, infoName, infoType);
      case 56:
         return ANARI_GEOMETRY_sphere_vertex_position_info(paramType, infoName, infoType);
      case 57:
         return ANARI_GEOMETRY_sphere_vertex_radius_info(paramType, infoName, infoType);
      case 54:
         return ANARI_GEOMETRY_sphere_vertex_color_info(paramType, infoName, infoType);
      case 49:
         return ANARI_GEOMETRY_sphere_vertex_attribute0_info(paramType, infoName, infoType);
      case 50:
         return ANARI_GEOMETRY_sphere_vertex_attribute1_info(paramType, infoName, infoType);
      case 51:
         return ANARI_GEOMETRY_sphere_vertex_attribute2_info(paramType, infoName, infoType);
      case 52:
         return ANARI_GEOMETRY_sphere_vertex_attribute3_info(paramType, infoName, infoType);
      case 39:
         return ANARI_GEOMETRY_sphere_primitive_index_info(paramType, infoName, infoType);
      case 41:
         return ANARI_GEOMETRY_sphere_radius_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_primitive_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_primitive_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_primitive_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_primitive_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_primitive_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_primitive_id_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "primitive id";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_vertex_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex position";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_vertex_normal_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex normal";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_FIXED16_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_vertex_tangent_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex normal";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_FIXED16_VEC3, ANARI_FLOAT32_VEC4, ANARI_FIXED16_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_vertex_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_vertex_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_vertex_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_vertex_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_vertex_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_primitive_index_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "index array";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32_VEC3, ANARI_UINT64_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 25:
         return ANARI_GEOMETRY_triangle_name_info(paramType, infoName, infoType);
      case 37:
         return ANARI_GEOMETRY_triangle_primitive_color_info(paramType, infoName, infoType);
      case 33:
         return ANARI_GEOMETRY_triangle_primitive_attribute0_info(paramType, infoName, infoType);
      case 34:
         return ANARI_GEOMETRY_triangle_primitive_attribute1_info(paramType, infoName, infoType);
      case 35:
         return ANARI_GEOMETRY_triangle_primitive_attribute2_info(paramType, infoName, infoType);
      case 36:
         return ANARI_GEOMETRY_triangle_primitive_attribute3_info(paramType, infoName, infoType);
      case 38:
         return ANARI_GEOMETRY_triangle_primitive_id_info(paramType, infoName, infoType);
      case 56:
         return ANARI_GEOMETRY_triangle_vertex_position_info(paramType, infoName, infoType);
      case 55:
         return ANARI_GEOMETRY_triangle_vertex_normal_info(paramType, infoName, infoType);
      case 58:
         return ANARI_GEOMETRY_triangle_vertex_tangent_info(paramType, infoName, infoType);
      case 54:
         return ANARI_GEOMETRY_triangle_vertex_color_info(paramType, infoName, infoType);
      case 49:
         return ANARI_GEOMETRY_triangle_vertex_attribute0_info(paramType, infoName, infoType);
      case 50:
         return ANARI_GEOMETRY_triangle_vertex_attribute1_info(paramType, infoName, infoType);
      case 51:
         return ANARI_GEOMETRY_triangle_vertex_attribute2_info(paramType, infoName, infoType);
      case 52:
         return ANARI_GEOMETRY_triangle_vertex_attribute3_info(paramType, infoName, infoType);
      case 39:
         return ANARI_GEOMETRY_triangle_primitive_index_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_MATERIAL_matte_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_MATERIAL_MATTE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 8;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_matte_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.800000f, 0.800000f, 0.800000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "color";
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "diffuse color";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"color", "worldPosition", "worldNormal", "objectPosition", "objectNormal", "attribute0", "attribute1", "attribute2", "attribute3", "primitiveId", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_MATERIAL_MATTE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 8;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_matte_opacity_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "opacity";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"color", "worldPosition", "worldNormal", "objectPosition", "objectNormal", "attribute0", "attribute1", "attribute2", "attribute3", "primitiveId", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_MATERIAL_MATTE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 8;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_matte_alphaMode_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "opaque";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "alpha mode";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"opaque", "blend", "mask", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_MATERIAL_MATTE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 8;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_matte_alphaCutoff_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0.500000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "cutoff for alpha mask mode";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_MATERIAL_MATTE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 8;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_matte_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 25:
         return ANARI_MATERIAL_matte_name_info(paramType, infoName, infoType);
      case 8:
         return ANARI_MATERIAL_matte_color_info(paramType, infoName, infoType);
      case 27:
         return ANARI_MATERIAL_matte_opacity_info(paramType, infoName, infoType);
      case 1:
         return ANARI_MATERIAL_matte_alphaMode_info(paramType, infoName, infoType);
      case 0:
         return ANARI_MATERIAL_matte_alphaCutoff_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_LIGHT_point_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_POINT";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 9;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_point_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "color";
         } else {
            return nullptr;
         }
      case 2: // minimum
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 3: // maximum
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "color of the light";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_POINT";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 9;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_point_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "point";
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "position of the light source";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_POINT";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 9;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_point_intensity_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "overall amount of light emitted in a direction in W/sr";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_POINT";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 9;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_point_power_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "overall amount of light energy emitted in W";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_POINT";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 9;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_point_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 25:
         return ANARI_LIGHT_point_name_info(paramType, infoName, infoType);
      case 8:
         return ANARI_LIGHT_point_color_info(paramType, infoName, infoType);
      case 31:
         return ANARI_LIGHT_point_position_info(paramType, infoName, infoType);
      case 22:
         return ANARI_LIGHT_point_intensity_info(paramType, infoName, infoType);
      case 32:
         return ANARI_LIGHT_point_power_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE1D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 10;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_image_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array backing the sampler";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE1D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 10;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_inAttribute_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "attribute0";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "input surface attribute (texture coordinate)";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"color", "worldPosition", "worldNormal", "objectPosition", "objectNormal", "attribute0", "attribute1", "attribute2", "attribute3", "primitiveId", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE1D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 10;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_filter_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "nearest";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "filter mode";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"nearest", "linear", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE1D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 10;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_wrapMode1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "clampToEdge";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "wrap mode for the 1st dimension";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"clampToEdge", "repeat", "mirrorRepeat", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE1D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 10;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_inTransform_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
            static const float default_value[16] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "transform applied to the input attribute before sampling";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE1D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 10;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_inOffset_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
            static const float default_value[4] = {0.000000f, 0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "offset added to output inTransform result";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE1D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 10;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_outTransform_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
            static const float default_value[16] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "transform applied to the sampled values";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE1D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 10;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_outOffset_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
            static const float default_value[4] = {0.000000f, 0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "offset added to output outTransform result";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE1D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 10;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 25:
         return ANARI_SAMPLER_image1D_name_info(paramType, infoName, infoType);
      case 16:
         return ANARI_SAMPLER_image1D_image_info(paramType, infoName, infoType);
      case 18:
         return ANARI_SAMPLER_image1D_inAttribute_info(paramType, infoName, infoType);
      case 12:
         return ANARI_SAMPLER_image1D_filter_info(paramType, infoName, infoType);
      case 61:
         return ANARI_SAMPLER_image1D_wrapMode1_info(paramType, infoName, infoType);
      case 20:
         return ANARI_SAMPLER_image1D_inTransform_info(paramType, infoName, infoType);
      case 19:
         return ANARI_SAMPLER_image1D_inOffset_info(paramType, infoName, infoType);
      case 30:
         return ANARI_SAMPLER_image1D_outTransform_info(paramType, infoName, infoType);
      case 29:
         return ANARI_SAMPLER_image1D_outOffset_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SPATIAL_FIELD_structuredRegular_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 11;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SPATIAL_FIELD_structuredRegular_data_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array of vertex centered scalar values";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT8, ANARI_INT16, ANARI_UINT16, ANARI_FLOAT32, ANARI_FLOAT64, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 11;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SPATIAL_FIELD_structuredRegular_origin_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "origin of the grid in object-space";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 11;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SPATIAL_FIELD_structuredRegular_spacing_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "size of the grid cells in object-space";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 11;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SPATIAL_FIELD_structuredRegular_filter_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "linear";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "filter mode used to interpolate the grid";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"nearest", "linear", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 11;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SPATIAL_FIELD_structuredRegular_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 25:
         return ANARI_SPATIAL_FIELD_structuredRegular_name_info(paramType, infoName, infoType);
      case 9:
         return ANARI_SPATIAL_FIELD_structuredRegular_data_info(paramType, infoName, infoType);
      case 28:
         return ANARI_SPATIAL_FIELD_structuredRegular_origin_info(paramType, infoName, infoType);
      case 44:
         return ANARI_SPATIAL_FIELD_structuredRegular_spacing_info(paramType, infoName, infoType);
      case 12:
         return ANARI_SPATIAL_FIELD_structuredRegular_filter_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_CAMERA_param_info(const char *subtype, const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 7:
         return ANARI_CAMERA_orthographic_param_info(paramName, paramType, infoName, infoType);
      case 8:
         return ANARI_CAMERA_perspective_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GEOMETRY_param_info(const char *subtype, const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 0:
         return ANARI_GEOMETRY_cone_param_info(paramName, paramType, infoName, infoType);
      case 1:
         return ANARI_GEOMETRY_curve_param_info(paramName, paramType, infoName, infoType);
      case 2:
         return ANARI_GEOMETRY_cylinder_param_info(paramName, paramType, infoName, infoType);
      case 10:
         return ANARI_GEOMETRY_quad_param_info(paramName, paramType, infoName, infoType);
      case 11:
         return ANARI_GEOMETRY_sphere_param_info(paramName, paramType, infoName, infoType);
      case 13:
         return ANARI_GEOMETRY_triangle_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_LIGHT_param_info(const char *subtype, const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 9:
         return ANARI_LIGHT_point_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_MATERIAL_param_info(const char *subtype, const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 6:
         return ANARI_MATERIAL_matte_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_RENDERER_param_info(const char *subtype, const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 3:
         return ANARI_RENDERER_default_param_info(paramName, paramType, infoName, infoType);
      case 4:
         return ANARI_RENDERER_direct_light_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SAMPLER_param_info(const char *subtype, const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 5:
         return ANARI_SAMPLER_image1D_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SPATIAL_FIELD_param_info(const char *subtype, const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 12:
         return ANARI_SPATIAL_FIELD_structuredRegular_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
const void * query_param_info_enum(ANARIDataType type, const char *subtype, const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(type) {
      case ANARI_CAMERA:
         return ANARI_CAMERA_param_info(subtype, paramName, paramType, infoName, infoType);
      case ANARI_GEOMETRY:
         return ANARI_GEOMETRY_param_info(subtype, paramName, paramType, infoName, infoType);
      case ANARI_LIGHT:
         return ANARI_LIGHT_param_info(subtype, paramName, paramType, infoName, infoType);
      case ANARI_MATERIAL:
         return ANARI_MATERIAL_param_info(subtype, paramName, paramType, infoName, infoType);
      case ANARI_RENDERER:
         return ANARI_RENDERER_param_info(subtype, paramName, paramType, infoName, infoType);
      case ANARI_SAMPLER:
         return ANARI_SAMPLER_param_info(subtype, paramName, paramType, infoName, infoType);
      case ANARI_SPATIAL_FIELD:
         return ANARI_SPATIAL_FIELD_param_info(subtype, paramName, paramType, infoName, infoType);
      case ANARI_DEVICE:
         return ANARI_DEVICE_param_info(paramName, paramType, infoName, infoType);
      case ANARI_ARRAY1D:
         return ANARI_ARRAY1D_param_info(paramName, paramType, infoName, infoType);
      case ANARI_ARRAY2D:
         return ANARI_ARRAY2D_param_info(paramName, paramType, infoName, infoType);
      case ANARI_ARRAY3D:
         return ANARI_ARRAY3D_param_info(paramName, paramType, infoName, infoType);
      case ANARI_FRAME:
         return ANARI_FRAME_param_info(paramName, paramType, infoName, infoType);
      case ANARI_GROUP:
         return ANARI_GROUP_param_info(paramName, paramType, infoName, infoType);
      case ANARI_WORLD:
         return ANARI_WORLD_param_info(paramName, paramType, infoName, infoType);
      case ANARI_SURFACE:
         return ANARI_SURFACE_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
const void * query_param_info(ANARIDataType type, const char *subtype, const char *paramName, ANARIDataType paramType, const char *infoNameString, ANARIDataType infoType) {
   int infoName = info_hash(infoNameString);
   return query_param_info_enum(type, subtype, paramName, paramType, infoName, infoType);
}
static const void * ANARI_RENDERER_default_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "default renderer";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"name", ANARI_STRING},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 8: // extension
         if(infoType == ANARI_STRING_LIST) {
            static const char *extensions[] = {
               "ANARI_KHR_CAMERA_ORTHOGRAPHIC",
               "ANARI_KHR_CAMERA_PERSPECTIVE",
               "ANARI_KHR_GEOMETRY_CONE",
               "ANARI_KHR_GEOMETRY_CURVE",
               "ANARI_KHR_GEOMETRY_CYLINDER",
               "ANARI_KHR_GEOMETRY_QUAD",
               "ANARI_KHR_GEOMETRY_SPHERE",
               "ANARI_KHR_GEOMETRY_TRIANGLE",
               "ANARI_KHR_MATERIAL_MATTE",
               "ANARI_KHR_LIGHT_POINT",
               "ANARI_KHR_SAMPLER_IMAGE1D",
               "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
               0
            };
            return extensions;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_direct_light_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"backgroundColor", ANARI_FLOAT32_VEC4},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 8: // extension
         if(infoType == ANARI_STRING_LIST) {
            static const char *extensions[] = {
               "ANARI_KHR_CAMERA_ORTHOGRAPHIC",
               "ANARI_KHR_CAMERA_PERSPECTIVE",
               "ANARI_KHR_GEOMETRY_CONE",
               "ANARI_KHR_GEOMETRY_CURVE",
               "ANARI_KHR_GEOMETRY_CYLINDER",
               "ANARI_KHR_GEOMETRY_QUAD",
               "ANARI_KHR_GEOMETRY_SPHERE",
               "ANARI_KHR_GEOMETRY_TRIANGLE",
               "ANARI_KHR_MATERIAL_MATTE",
               "ANARI_KHR_LIGHT_POINT",
               "ANARI_KHR_SAMPLER_IMAGE1D",
               "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
               0
            };
            return extensions;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_DEVICE_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "device object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"statusCallback", ANARI_STATUS_CALLBACK},
               {"statusCallbackUserData", ANARI_VOID_POINTER},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 8: // extension
         if(infoType == ANARI_STRING_LIST) {
            static const char *extensions[] = {
               "ANARI_KHR_CAMERA_ORTHOGRAPHIC",
               "ANARI_KHR_CAMERA_PERSPECTIVE",
               "ANARI_KHR_GEOMETRY_CONE",
               "ANARI_KHR_GEOMETRY_CURVE",
               "ANARI_KHR_GEOMETRY_CYLINDER",
               "ANARI_KHR_GEOMETRY_QUAD",
               "ANARI_KHR_GEOMETRY_SPHERE",
               "ANARI_KHR_GEOMETRY_TRIANGLE",
               "ANARI_KHR_MATERIAL_MATTE",
               "ANARI_KHR_LIGHT_POINT",
               "ANARI_KHR_SAMPLER_IMAGE1D",
               "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
               0
            };
            return extensions;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_ARRAY1D_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "one dimensional array object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_ARRAY2D_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "two dimensional array object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_ARRAY3D_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "three dimensional array object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "frame object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"world", ANARI_WORLD},
               {"renderer", ANARI_RENDERER},
               {"camera", ANARI_CAMERA},
               {"size", ANARI_UINT32_VEC2},
               {"channel.color", ANARI_DATA_TYPE},
               {"channel.depth", ANARI_DATA_TYPE},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 10: // channel
         if(infoType == ANARI_STRING_LIST) {
            static const char *channel[] = {
               "channel.color",
               "channel.depth",
               0
            };
            return channel;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GROUP_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "group object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"surface", ANARI_ARRAY1D},
               {"volume", ANARI_ARRAY1D},
               {"light", ANARI_ARRAY1D},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_WORLD_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "world object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"instance", ANARI_ARRAY1D},
               {"surface", ANARI_ARRAY1D},
               {"volume", ANARI_ARRAY1D},
               {"light", ANARI_ARRAY1D},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SURFACE_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "surface object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"geometry", ANARI_GEOMETRY},
               {"material", ANARI_MATERIAL},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "orthographic camera object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"position", ANARI_FLOAT32_VEC3},
               {"direction", ANARI_FLOAT32_VEC3},
               {"up", ANARI_FLOAT32_VEC3},
               {"imageRegion", ANARI_FLOAT32_BOX2},
               {"aspect", ANARI_FLOAT32},
               {"height", ANARI_FLOAT32},
               {"near", ANARI_FLOAT32},
               {"far", ANARI_FLOAT32},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 0;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "perspective camera object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"position", ANARI_FLOAT32_VEC3},
               {"direction", ANARI_FLOAT32_VEC3},
               {"up", ANARI_FLOAT32_VEC3},
               {"imageRegion", ANARI_FLOAT32_BOX2},
               {"fovy", ANARI_FLOAT32},
               {"aspect", ANARI_FLOAT32},
               {"near", ANARI_FLOAT32},
               {"far", ANARI_FLOAT32},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_PERSPECTIVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 1;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "cone geometry object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"primitive.color", ANARI_ARRAY1D},
               {"primitive.attribute0", ANARI_ARRAY1D},
               {"primitive.attribute1", ANARI_ARRAY1D},
               {"primitive.attribute2", ANARI_ARRAY1D},
               {"primitive.attribute3", ANARI_ARRAY1D},
               {"primitive.id", ANARI_ARRAY1D},
               {"vertex.position", ANARI_ARRAY1D},
               {"vertex.radius", ANARI_ARRAY1D},
               {"vertex.cap", ANARI_ARRAY1D},
               {"vertex.color", ANARI_ARRAY1D},
               {"vertex.attribute0", ANARI_ARRAY1D},
               {"vertex.attribute1", ANARI_ARRAY1D},
               {"vertex.attribute2", ANARI_ARRAY1D},
               {"vertex.attribute3", ANARI_ARRAY1D},
               {"primitive.index", ANARI_ARRAY1D},
               {"caps", ANARI_STRING},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 2;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "curve geometry object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"primitive.color", ANARI_ARRAY1D},
               {"primitive.attribute0", ANARI_ARRAY1D},
               {"primitive.attribute1", ANARI_ARRAY1D},
               {"primitive.attribute2", ANARI_ARRAY1D},
               {"primitive.attribute3", ANARI_ARRAY1D},
               {"primitive.id", ANARI_ARRAY1D},
               {"vertex.position", ANARI_ARRAY1D},
               {"vertex.radius", ANARI_ARRAY1D},
               {"vertex.color", ANARI_ARRAY1D},
               {"vertex.attribute0", ANARI_ARRAY1D},
               {"vertex.attribute1", ANARI_ARRAY1D},
               {"vertex.attribute2", ANARI_ARRAY1D},
               {"vertex.attribute3", ANARI_ARRAY1D},
               {"primitive.index", ANARI_ARRAY1D},
               {"radius", ANARI_FLOAT32},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 3;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "cylinder geometry object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"primitive.color", ANARI_ARRAY1D},
               {"primitive.attribute0", ANARI_ARRAY1D},
               {"primitive.attribute1", ANARI_ARRAY1D},
               {"primitive.attribute2", ANARI_ARRAY1D},
               {"primitive.attribute3", ANARI_ARRAY1D},
               {"primitive.id", ANARI_ARRAY1D},
               {"vertex.position", ANARI_ARRAY1D},
               {"vertex.cap", ANARI_ARRAY1D},
               {"vertex.color", ANARI_ARRAY1D},
               {"vertex.attribute0", ANARI_ARRAY1D},
               {"vertex.attribute1", ANARI_ARRAY1D},
               {"vertex.attribute2", ANARI_ARRAY1D},
               {"vertex.attribute3", ANARI_ARRAY1D},
               {"primitive.index", ANARI_ARRAY1D},
               {"primitive.radius", ANARI_ARRAY1D},
               {"radius", ANARI_FLOAT32},
               {"caps", ANARI_STRING},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 4;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "quad geometry object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"primitive.color", ANARI_ARRAY1D},
               {"primitive.attribute0", ANARI_ARRAY1D},
               {"primitive.attribute1", ANARI_ARRAY1D},
               {"primitive.attribute2", ANARI_ARRAY1D},
               {"primitive.attribute3", ANARI_ARRAY1D},
               {"primitive.id", ANARI_ARRAY1D},
               {"vertex.position", ANARI_ARRAY1D},
               {"vertex.normal", ANARI_ARRAY1D},
               {"vertex.tangent", ANARI_ARRAY1D},
               {"vertex.color", ANARI_ARRAY1D},
               {"vertex.attribute0", ANARI_ARRAY1D},
               {"vertex.attribute1", ANARI_ARRAY1D},
               {"vertex.attribute2", ANARI_ARRAY1D},
               {"vertex.attribute3", ANARI_ARRAY1D},
               {"primitive.index", ANARI_ARRAY1D},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 5;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "sphere geometry object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"primitive.color", ANARI_ARRAY1D},
               {"primitive.attribute0", ANARI_ARRAY1D},
               {"primitive.attribute1", ANARI_ARRAY1D},
               {"primitive.attribute2", ANARI_ARRAY1D},
               {"primitive.attribute3", ANARI_ARRAY1D},
               {"primitive.id", ANARI_ARRAY1D},
               {"vertex.position", ANARI_ARRAY1D},
               {"vertex.radius", ANARI_ARRAY1D},
               {"vertex.color", ANARI_ARRAY1D},
               {"vertex.attribute0", ANARI_ARRAY1D},
               {"vertex.attribute1", ANARI_ARRAY1D},
               {"vertex.attribute2", ANARI_ARRAY1D},
               {"vertex.attribute3", ANARI_ARRAY1D},
               {"primitive.index", ANARI_ARRAY1D},
               {"radius", ANARI_FLOAT32},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 6;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "triangle geometry object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"primitive.color", ANARI_ARRAY1D},
               {"primitive.attribute0", ANARI_ARRAY1D},
               {"primitive.attribute1", ANARI_ARRAY1D},
               {"primitive.attribute2", ANARI_ARRAY1D},
               {"primitive.attribute3", ANARI_ARRAY1D},
               {"primitive.id", ANARI_ARRAY1D},
               {"vertex.position", ANARI_ARRAY1D},
               {"vertex.normal", ANARI_ARRAY1D},
               {"vertex.tangent", ANARI_ARRAY1D},
               {"vertex.color", ANARI_ARRAY1D},
               {"vertex.attribute0", ANARI_ARRAY1D},
               {"vertex.attribute1", ANARI_ARRAY1D},
               {"vertex.attribute2", ANARI_ARRAY1D},
               {"vertex.attribute3", ANARI_ARRAY1D},
               {"primitive.index", ANARI_ARRAY1D},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 7;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_matte_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "matte material object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"color", ANARI_FLOAT32_VEC3},
               {"color", ANARI_SAMPLER},
               {"color", ANARI_STRING},
               {"opacity", ANARI_FLOAT32},
               {"opacity", ANARI_SAMPLER},
               {"opacity", ANARI_STRING},
               {"alphaMode", ANARI_STRING},
               {"alphaCutoff", ANARI_FLOAT32},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_MATERIAL_MATTE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 8;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_point_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "point light object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"color", ANARI_FLOAT32_VEC3},
               {"position", ANARI_FLOAT32_VEC3},
               {"intensity", ANARI_FLOAT32},
               {"power", ANARI_FLOAT32},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_POINT";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 9;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "image1D object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"image", ANARI_ARRAY1D},
               {"inAttribute", ANARI_STRING},
               {"filter", ANARI_STRING},
               {"wrapMode1", ANARI_STRING},
               {"inTransform", ANARI_FLOAT32_MAT4},
               {"inOffset", ANARI_FLOAT32_VEC4},
               {"outTransform", ANARI_FLOAT32_MAT4},
               {"outOffset", ANARI_FLOAT32_VEC4},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE1D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 10;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SPATIAL_FIELD_structuredRegular_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "structured regular spatial field object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"data", ANARI_ARRAY3D},
               {"origin", ANARI_FLOAT32_VEC3},
               {"spacing", ANARI_FLOAT32_VEC3},
               {"filter", ANARI_STRING},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 11;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_info(const char *subtype, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 7:
         return ANARI_CAMERA_orthographic_info(infoName, infoType);
      case 8:
         return ANARI_CAMERA_perspective_info(infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GEOMETRY_info(const char *subtype, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 0:
         return ANARI_GEOMETRY_cone_info(infoName, infoType);
      case 1:
         return ANARI_GEOMETRY_curve_info(infoName, infoType);
      case 2:
         return ANARI_GEOMETRY_cylinder_info(infoName, infoType);
      case 10:
         return ANARI_GEOMETRY_quad_info(infoName, infoType);
      case 11:
         return ANARI_GEOMETRY_sphere_info(infoName, infoType);
      case 13:
         return ANARI_GEOMETRY_triangle_info(infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_LIGHT_info(const char *subtype, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 9:
         return ANARI_LIGHT_point_info(infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_MATERIAL_info(const char *subtype, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 6:
         return ANARI_MATERIAL_matte_info(infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_RENDERER_info(const char *subtype, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 3:
         return ANARI_RENDERER_default_info(infoName, infoType);
      case 4:
         return ANARI_RENDERER_direct_light_info(infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SAMPLER_info(const char *subtype, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 5:
         return ANARI_SAMPLER_image1D_info(infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SPATIAL_FIELD_info(const char *subtype, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 12:
         return ANARI_SPATIAL_FIELD_structuredRegular_info(infoName, infoType);
      default:
         return nullptr;
   }
}
const void * query_object_info_enum(ANARIDataType type, const char *subtype, int infoName, ANARIDataType infoType) {
   switch(type) {
      case ANARI_CAMERA:
         return ANARI_CAMERA_info(subtype, infoName, infoType);
      case ANARI_GEOMETRY:
         return ANARI_GEOMETRY_info(subtype, infoName, infoType);
      case ANARI_LIGHT:
         return ANARI_LIGHT_info(subtype, infoName, infoType);
      case ANARI_MATERIAL:
         return ANARI_MATERIAL_info(subtype, infoName, infoType);
      case ANARI_RENDERER:
         return ANARI_RENDERER_info(subtype, infoName, infoType);
      case ANARI_SAMPLER:
         return ANARI_SAMPLER_info(subtype, infoName, infoType);
      case ANARI_SPATIAL_FIELD:
         return ANARI_SPATIAL_FIELD_info(subtype, infoName, infoType);
      case ANARI_DEVICE:
         return ANARI_DEVICE_info(infoName, infoType);
      case ANARI_ARRAY1D:
         return ANARI_ARRAY1D_info(infoName, infoType);
      case ANARI_ARRAY2D:
         return ANARI_ARRAY2D_info(infoName, infoType);
      case ANARI_ARRAY3D:
         return ANARI_ARRAY3D_info(infoName, infoType);
      case ANARI_FRAME:
         return ANARI_FRAME_info(infoName, infoType);
      case ANARI_GROUP:
         return ANARI_GROUP_info(infoName, infoType);
      case ANARI_WORLD:
         return ANARI_WORLD_info(infoName, infoType);
      case ANARI_SURFACE:
         return ANARI_SURFACE_info(infoName, infoType);
      default:
         return nullptr;
   }
}
const void * query_object_info(ANARIDataType type, const char *subtype, const char *infoNameString, ANARIDataType infoType) {
   int infoName = info_hash(infoNameString);   return query_object_info_enum(type, subtype, infoName, infoType);}
}
